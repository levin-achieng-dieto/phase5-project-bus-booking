import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { getComputedStyle } from '../utils';
import PluginMixins from './PluginMixins';

var SvgDraw = /*#__PURE__*/function (_PluginMixins) {
  _inherits(SvgDraw, _PluginMixins);

  var _super = _createSuper(SvgDraw);

  function SvgDraw() {
    var _this;

    _classCallCheck(this, SvgDraw);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.computedStyle = void 0;
    _this.length = 0;

    _this.getAnimStart = function () {
      var _assertThisInitialize = _assertThisInitialized(_this),
          target = _assertThisInitialize.target,
          startAt = _assertThisInitialize.startAt,
          key = _assertThisInitialize.key;

      if (!target) {
        return;
      }

      if (!_this.computedStyle) {
        _this.computedStyle = getComputedStyle(target);
      }

      var _assertThisInitialize2 = _assertThisInitialized(_this),
          computedStyle = _assertThisInitialize2.computedStyle;

      var tagName = target.tagName;

      var getAttribute = function getAttribute(str) {
        return target.getAttribute(str);
      };

      switch (tagName) {
        case 'circle':
          _this.length = Math.PI * 2 * getAttribute('r');
          break;

        case 'line':
          _this.length = _this.getLineLength(getAttribute('x1'), getAttribute('y1'), getAttribute('x2'), getAttribute('y2'));
          break;

        case 'polyline':
        case 'polygon':
          _this.length = _this.getPolyLength(tagName);
          break;

        case 'ellipse':
          _this.length = _this.getEllipseLength();
          break;

        case 'rect':
          _this.length = getAttribute('width') * 2 + getAttribute('height') * 2;
          break;

        case 'path':
          _this.length = target.getTotalLength();
          break;

        default:
          throw new Error('The label is not a label in the SVG.');
      }

      _this.length = parseFloat(_this.length.toFixed(3));
      var strokeDasharray;
      var strokeDashoffset;

      if (startAt[key] || startAt[key] === 0) {
        strokeDasharray = _this.setVars(startAt[key]);
        strokeDashoffset = -strokeDasharray.start;
      } else {
        strokeDasharray = computedStyle.strokeDasharray === 'none' || !computedStyle.strokeDasharray ? '100% 100%' : computedStyle.strokeDasharray;
        strokeDashoffset = parseFloat(computedStyle.strokeDashoffset);
        strokeDasharray = strokeDasharray.split(' ')[0].replace(/\,/i, '');
        strokeDasharray = strokeDasharray.indexOf('%') >= 0 ? parseFloat(strokeDasharray) / 100 * _this.length : parseFloat(strokeDasharray);
        strokeDasharray = _this.setVars("".concat(-strokeDashoffset, " ").concat(strokeDasharray - strokeDashoffset));
      }

      _this.start.strokeDasharray = strokeDasharray;
      _this.start.strokeDashoffset = strokeDashoffset;
      _this.value = _this.setVars(_this.value);
      return _this.start;
    };

    _this.render = function (r) {
      var _assertThisInitialize3 = _assertThisInitialized(_this),
          value = _assertThisInitialize3.value,
          start = _assertThisInitialize3.start,
          length = _assertThisInitialize3.length;

      var s = start.strokeDasharray,
          sdf = start.strokeDashoffset;
      var v = s.end - s.start + (value.end - s.end - (value.start - s.start)) * r;
      return {
        strokeDasharray: "".concat(v, "px, ").concat(length, "px"),
        strokeDashoffset: -((value.start + sdf) * r - sdf)
      };
    };

    return _this;
  }

  _createClass(SvgDraw, [{
    key: "setVars",
    value: function setVars(value) {
      var v = {
        start: 0
      };

      if (typeof value === 'number') {
        v.end = value;
        return v;
      }

      var data = value.split(' ');

      if (data.length > 1) {
        v.start = data[0].indexOf('%') >= 0 ? parseFloat(data[0]) / 100 * this.length : parseFloat(data[0]);
        v.end = data[1].indexOf('%') >= 0 ? parseFloat(data[1]) / 100 * this.length : parseFloat(data[1]);
      } else if (parseFloat(value)) {
        v.end = value.indexOf('%') >= 0 ? parseFloat(value) / 100 * this.length : parseFloat(value);
      } else {
        throw new Error("SVGDraw data[".concat(value, "] error."));
      }

      return v;
    }
  }, {
    key: "getPolyLength",
    value: function getPolyLength(name) {
      var _this2 = this;

      // .match(/(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi)
      var pointsArray = [];
      (this.target.getAttribute('points') || '').split(/[\s+|,]/).forEach(function (item, i) {
        var arr = pointsArray[Math.floor(i / 2)] || [];
        arr.push(parseFloat(item));

        if (!(i % 2)) {
          pointsArray.push(arr);
        }
      });

      if (name === 'polygon') {
        pointsArray.push(pointsArray[0]);
      }

      var length = 0;
      pointsArray.forEach(function (item, i) {
        if (i < pointsArray.length - 1) {
          var nextPoint = pointsArray[i + 1];
          length += _this2.getLineLength(item[0], item[1], nextPoint[0], nextPoint[1]);
        }
      });
      return length;
    }
  }, {
    key: "getEllipseLength",
    value: function getEllipseLength() {
      var rx = parseFloat(this.target.getAttribute('rx'));
      var ry = parseFloat(this.target.getAttribute('ry'));

      if (!rx || !ry) {
        throw new Error("ellipse rx or ry error.");
      }

      return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (3 * ry + rx)));
    }
  }, {
    key: "getLineLength",
    value: function getLineLength(x1, y1, x2, y2) {
      var x = parseFloat(x2) - parseFloat(x1);
      var y = parseFloat(y2) - parseFloat(y1);
      return Math.sqrt(x * x + y * y);
    }
  }]);

  return SvgDraw;
}(PluginMixins);

SvgDraw.key = 'style';
SvgDraw.className = 'SVGDraw';
export { SvgDraw as default };