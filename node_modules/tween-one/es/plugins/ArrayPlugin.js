import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { parseColor, getColor, parseShadow } from 'style-utils';
import { getValue, shadowExp, startConvertToEndUnit, styleValueToArray, colorRegExp } from '../utils';
import PluginMixins from './PluginMixins';

var ArrayPlugin = /*#__PURE__*/function (_PluginMixins) {
  _inherits(ArrayPlugin, _PluginMixins);

  var _super = _createSuper(ArrayPlugin);

  function ArrayPlugin(_value, _key) {
    var _this;

    _classCallCheck(this, ArrayPlugin);

    _this = _super.call(this, _value, _key);
    _this.value = void 0;
    _this.key = void 0;
    _this.start = [];
    _this.tweenVars = {};
    _this.vars = {};
    _this.computedStyle = void 0;
    _this.propsData = {
      data: [],
      unit: [],
      count: []
    };

    _this.setDefaultData = function (type, splitStr) {
      var _assertThisInitialize = _assertThisInitialized(_this),
          propsData = _assertThisInitialize.propsData,
          value = _assertThisInitialize.value;

      var v = _toConsumableArray(value);

      if (type === 'color') {
        var _v$;

        v[3] = (_v$ = v[3]) !== null && _v$ !== void 0 ? _v$ : 1;
      }

      propsData.type = type;
      propsData.data = v.map(function (c) {
        return !parseFloat(c) && parseFloat(c) !== 0 ? c : parseFloat(c);
      });
      propsData.unit = v.map(function (c) {
        return c.toString().replace(/[^a-z|%]/g, '');
      });
      propsData.count = v.map(function (c) {
        return c.toString().replace(/[^+|=|-]/g, '');
      });

      if (splitStr) {
        propsData.splitStr = splitStr;
      }
    };

    _this.convertToMarksArray = function (unit, key, data, i) {
      var startUnit = (data || '').toString().replace(/[^a-z|%]/g, '');
      var endUnit = typeof i === 'number' ? unit[i] : undefined;

      if (startUnit === endUnit) {
        return parseFloat(data);
      } else if (!parseFloat(data) && parseFloat(data) !== 0) {
        return data;
      }

      return startConvertToEndUnit({
        target: _this.target,
        computedStyle: _this.computedStyle,
        style: key,
        value: data,
        startUnit: startUnit,
        endUnit: endUnit,
        isOriginWidth: key === 'transformOrigin' && !i
      });
    };

    _this.getAnimStart = function () {
      var _ref, _ref2, _startAt$key, _tweenVars$style;

      var _assertThisInitialize2 = _assertThisInitialized(_this),
          startAt = _assertThisInitialize2.startAt,
          target = _assertThisInitialize2.target,
          key = _assertThisInitialize2.key,
          propsData = _assertThisInitialize2.propsData,
          computedStyle = _assertThisInitialize2.computedStyle,
          tweenVars = _assertThisInitialize2.tweenVars;

      var startValue = (_ref = (_ref2 = (_startAt$key = startAt === null || startAt === void 0 ? void 0 : startAt[key]) !== null && _startAt$key !== void 0 ? _startAt$key : computedStyle ? (_tweenVars$style = tweenVars.style) === null || _tweenVars$style === void 0 ? void 0 : _tweenVars$style[key] : tweenVars[key]) !== null && _ref2 !== void 0 ? _ref2 : (computedStyle || target)[key]) !== null && _ref !== void 0 ? _ref : '';
      var inset = propsData.data.indexOf('inset');
      var oldShadow;

      if (inset !== -1 && !startValue.match('inset') && propsData.type === 'shadow') {
        oldShadow = startValue;
        startValue = '';
      }

      if (!startValue || startValue === 'none' || startValue === 'auto') {
        startValue = '';
      }

      startValue = propsData.type === 'shadow' ? parseShadow(startValue, key) : startValue;
      startValue = propsData.type === 'color' ? parseColor(startValue) : startValue;
      startValue = propsData.type === 'string' ? startValue.split(/[\s|,]/) : startValue;

      if (styleValueToArray[key]) {
        var _startValue$, _startValue$2, _ref3, _startValue$3;

        startValue[1] = (_startValue$ = startValue[1]) !== null && _startValue$ !== void 0 ? _startValue$ : startValue[0];
        startValue[2] = (_startValue$2 = startValue[2]) !== null && _startValue$2 !== void 0 ? _startValue$2 : startValue[0];
        startValue[3] = (_ref3 = (_startValue$3 = startValue[3]) !== null && _startValue$3 !== void 0 ? _startValue$3 : startValue[1]) !== null && _ref3 !== void 0 ? _ref3 : startValue[0];
      }

      var endUnit = propsData.unit;
      var startData = startValue.map(function (c, i) {
        if (parseFloat(c).toString() === 'NaN') {
          return c;
        }

        return _this.convertToMarksArray(endUnit, key, c, i);
      });
      _this.start = startData.concat(inset >= 0 ? 'inset' : []);
      _this.start.oldShadow = oldShadow;
      return _this.start;
    };

    _this.render = function (ratio) {
      var _assertThisInitialize3 = _assertThisInitialized(_this),
          start = _assertThisInitialize3.start,
          propsData = _assertThisInitialize3.propsData;

      var type = propsData.type,
          splitStr = propsData.splitStr,
          data = propsData.data,
          count = propsData.count,
          unit = propsData.unit;
      var ratioData = data.map(function (c, i) {
        return typeof c === 'string' ? c : getValue(start[i], c, ratio, count[i], unit[i]);
      });

      switch (type) {
        case 'string':
          ratioData = ratioData.join(splitStr);
          break;

        case 'color':
          ratioData = getColor(ratioData);
          break;

        case 'shadow':
          {
            var endInset = ratioData.indexOf('inset') >= 0;
            var r = endInset ? ratioData.filter(function (c) {
              return c !== 'inset';
            }) : ratioData;
            var s = r.slice(0, r.length - 4).map(function (a) {
              if (typeof a === 'number') {
                return "".concat(a, "px");
              }

              return a;
            });
            var c = getColor(r.slice(r.length - 4, r.length));
            ratioData = "".concat(start.oldShadow ? "".concat(start.oldShadow, ",") : '').concat(s.join(' '), " ").concat(c, " ").concat(endInset ? 'inset' : '').trim();
            break;
          }

        default:
          break;
      }

      return ratioData;
    };

    _this.value = _value;
    _this.key = _key;
    var _type = '';
    var _splitStr = '';

    if (typeof _value === 'string') {
      if (_key.match(shadowExp)) {
        _this.value = parseShadow(_value, _key);
        _type = 'shadow';
      } else if (_key.match(/color|fill|stroke/i) || _value.match(colorRegExp)) {
        _this.value = parseColor(_value);
        _type = 'color';
      } else {
        _splitStr = _value.replace(/[^\s|,]/g, '').replace(/\s+/g, ' ');
        _this.value = _value.split(/[\s|,]/);
        _type = 'string';
      }
    }

    _this.setDefaultData(_type, _splitStr);

    return _this;
  }

  return _createClass(ArrayPlugin);
}(PluginMixins);

ArrayPlugin.className = 'ArrayPlugin';
export default ArrayPlugin;