import _createClass from "@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { svgPathProperties } from 'svg-path-properties';
import { checkStyleName, getTransform } from 'style-utils';
import { getComputedStyle, getTransformValue, startConvertToEndUnit } from '../utils';
import { rawPathToString, arrayToRawPath } from './path-utils';
import PluginMixins from './PluginMixins';

var PathMotion = /*#__PURE__*/function (_PluginMixins) {
  _inherits(PathMotion, _PluginMixins);

  var _super = _createSuper(PathMotion);

  function PathMotion(_value, _key) {
    var _this;

    _classCallCheck(this, PathMotion);

    _this = _super.call(this, _value, _key);
    _this.value = void 0;
    _this.key = void 0;
    _this.path = void 0;
    _this.computedStyle = void 0;
    _this.pathLength = 0;
    _this.tweenVars = {};
    _this.keys = ['x', 'y', 'rotate'];

    _this.getAnimStart = function () {
      var _assertThisInitialize = _assertThisInitialized(_this),
          target = _assertThisInitialize.target,
          value = _assertThisInitialize.value,
          tweenVars = _assertThisInitialize.tweenVars;

      var tagName = target.tagName;

      if (tagName) {
        if (!_this.computedStyle) {
          _this.computedStyle = getComputedStyle(target);
        }

        if (tweenVars.style && tweenVars.style.transform) {
          _this.start = tweenVars.style.transform;
        } else {
          var transform = getTransform(_this.computedStyle[checkStyleName('transform')]);
          _this.start = transform;
          tweenVars.style = tweenVars.style || {};
          tweenVars.style.transform = tweenVars.style.transform || transform;
        }

        var _value$center = value.center,
            center = _value$center === void 0 ? ['50%', '50%'] : _value$center;
        _this.value.center = center.map(function (c, i) {
          return startConvertToEndUnit({
            target: target,
            computedStyle: _this.computedStyle,
            style: !i ? 'width' : 'height',
            value: parseFloat(c),
            startUnit: c.toString().replace(/[^a-z|%]/g, ''),
            useCurrentTarget: true
          });
        });
      } else {
        _this.start = {};

        _this.keys.forEach(function (key) {
          if (_this.value[key]) {
            _this.start[key] = 0;
          }
        });
      }
    };

    _this.getPoint = function (r, offset) {
      var o = offset || 0;
      var p = _this.pathLength * r + o;
      return _this.path ? _this.path.getPointAtLength(p) : 0;
    };

    _this.render = function (r) {
      var _assertThisInitialize2 = _assertThisInitialized(_this),
          value = _assertThisInitialize2.value,
          target = _assertThisInitialize2.target,
          getPoint = _assertThisInitialize2.getPoint,
          tweenVars = _assertThisInitialize2.tweenVars;

      var tagName = target.tagName;
      var p = getPoint(r);
      var p0 = getPoint(r, 0.5);
      var p1 = getPoint(r, -0.5);
      var rotate = value.rotate,
          x = value.x,
          y = value.y,
          _value$center2 = value.center,
          center = _value$center2 === void 0 ? [0, 0] : _value$center2;
      var vars = tagName ? tweenVars.style || {} : tweenVars;

      if (tagName) {
        if (rotate) {
          vars.transform.rotate = Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
        }

        if (x) {
          vars.transform.translateX = p.x - parseFloat(center[0]);
        }

        if (y) {
          vars.transform.translateY = p.y - parseFloat(center[1]);
        }

        vars.transform.text = getTransformValue(vars.transform);
      } else {
        if (rotate) {
          vars.rotate = Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
        }

        if (x) {
          vars.x = p.x - parseFloat(center[0]);
        }

        if (y) {
          vars.y = p.y - parseFloat(center[1]);
        }
      }

      return vars;
    };

    _this.value = _value;
    _this.key = _key;

    if (typeof _value === 'string') {
      _this.value = {
        path: _value
      };
    }

    _this.keys.forEach(function (key) {
      if (!(key in _this.value)) {
        _this.value[key] = true;
      }
    });

    var _this$value = _this.value,
        path = _this$value.path,
        pathVars = _this$value.pathVars;

    if (Array.isArray(path)) {
      path = pathVars.curviness !== 0 ? rawPathToString(arrayToRawPath(path, pathVars || {})) : path.map(function (item, i) {
        return "".concat(!i ? 'M' : 'L').concat(item.x, " ").concat(item.y);
      }).join('');
    }

    _this.path = new svgPathProperties(path);
    _this.pathLength = _this.path.getTotalLength();
    return _this;
  }

  return _createClass(PathMotion);
}(PluginMixins);

PathMotion.key = 'style';
PathMotion.className = 'PathMotion';
export { PathMotion as default };