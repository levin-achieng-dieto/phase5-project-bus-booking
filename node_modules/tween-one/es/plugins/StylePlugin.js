import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import { cssList, checkStyleName, getGsapType, isConvert, splitFilterToObject, getTransform, stylesToCss } from 'style-utils';
import { getComputedStyle, startConvertToEndUnit, getTransformValue, initFilterValue, getValue, getDefaultStart, getStartAtValue } from '../utils';
import Plugins from './';
var unitReg = /%|vw|vh|em|rem/i;

var style = /*#__PURE__*/_createClass( //CSSStyleDeclaration;
function style(_props) {
  var _this = this;

  _classCallCheck(this, style);

  this.props = void 0;
  this.computedStyle = void 0;
  this.root = void 0;
  this.index = void 0;
  this.targetIndex = void 0;
  this.tweenVars = {};
  this.transformName = void 0;
  this.filterName = void 0;
  this.target = void 0;
  this.start = {};
  this.startAt = {};
  this.propsData = {
    data: {},
    type: {},
    unit: {},
    count: {},
    splitStr: {},
    isTransform: {}
  };

  this.setDefaultData = function () {
    var props = _this.props;

    for (var k in props) {
      // Object.keys(props).forEach((k: string) => {
      var value = props[k];
      var isArray = value.split && value.split(/\s+|,/).length > 1 || k.match(/color|fill|stroke/i) || k.match(/shadow/i);
      var isGradients = (k === 'background' || k === 'backgroundImage') && value.match(/[a-z|-]+\(([\s\S]*?)\)/gi);

      if (isGradients) {
        _this.propsData.data[k] = {
          value: value,
          plugin: Plugins.GradientsPlugin
        };
        continue;
      }

      if (isArray) {
        _this.propsData.data[k] = {
          value: value,
          plugin: Plugins.ArrayPlugin
        };
        continue;
      }

      var key = getGsapType(k);

      var data = _this.getTweenData(key, props[k]);

      _this.propsData.data[key] = data.data[key];
      _this.propsData.type[key] = data.type[key];
      _this.propsData.unit[key] = data.unit[key];
      _this.propsData.count[key] = data.count[key];
      _this.propsData.isTransform[key] = isConvert(key) === 'transform';

      if (data.splitStr[key]) {
        _this.propsData.splitStr[key] = data.splitStr[key];
      } //});

    }
  };

  this.getTweenData = function (key, v) {
    var data = {
      data: {},
      isTransform: {},
      type: {},
      unit: {},
      count: {},
      splitStr: {}
    };
    var value = v;
    data.data[key] = value; // data.type[key] = 'other';

    var dataIsString = typeof data.data[key] === 'string';
    data.unit[key] = dataIsString ? data.data[key].replace(/[^a-z|%]/g, '') : '';
    data.count[key] = dataIsString ? data.data[key].replace(/[^+|=|-]/g, '') : '';
    var d = dataIsString ? parseFloat(data.data[key].replace(/[a-z|%|=]/g, '')) : data.data[key];
    data.data[key] = !d && d !== 0 ? data.data[key] : d;
    return data;
  };

  this.setStartAtValue = function (start, startAt) {
    return _typeof(startAt) === 'object' ? getStartAtValue(start, startAt) : start;
  };

  this.getAnimStart = function () {
    var target = _this.target,
        root = _this.root,
        targetIndex = _this.targetIndex,
        propsData = _this.propsData,
        s = _this.startAt,
        start = _this.start,
        tweenVars = _this.tweenVars;
    var startAt = {};

    for (var c in s) {
      //Object.keys(s).forEach(c => {
      startAt[getGsapType(c)] = s[c]; //});
    }

    _this.computedStyle = _this.computedStyle || getComputedStyle(target);
    tweenVars.style = tweenVars.style || {};
    var transform;
    var filter;

    for (var key in propsData.data) {
      var _startAt$key;

      var item = propsData.data[key];

      if (item.plugin) {
        var plugin = new item.plugin(item.value, key);
        plugin.target = target;
        plugin.root = root;
        plugin.parent = parent;
        plugin.index = _this.index;
        plugin.targetIndex = targetIndex;
        plugin.tweenVars = tweenVars;
        plugin.startAt = _this.startAt;
        plugin.computedStyle = _this.computedStyle;
        item.plugin = plugin;
        start[key] = plugin.getAnimStart();
        continue;
      }

      var cssName = isConvert(key);
      var styleKey = cssName === 'transform' ? _this.transformName : cssName;
      styleKey = cssName === 'filter' ? _this.filterName : styleKey;
      var varsValue = tweenVars.style[styleKey];
      var styleValue = varsValue !== null && varsValue !== void 0 ? varsValue : _this.computedStyle[cssName];
      var startData = (_startAt$key = startAt[key]) !== null && _startAt$key !== void 0 ? _startAt$key : styleValue;
      var endUnit = propsData.unit[key];
      var startUnit = '';

      if (cssName === 'transform') {
        transform = transform || (startData === varsValue ? _objectSpread({}, varsValue) : getTransform(_this.computedStyle[_this.transformName]));
        var startValue = transform[key];

        if (startAt && key in startAt) {
          var _ref, _startAt$key$vars;

          startValue = _this.setStartAtValue((_ref = (_startAt$key$vars = startAt[key].vars) !== null && _startAt$key$vars !== void 0 ? _startAt$key$vars : varsValue === null || varsValue === void 0 ? void 0 : varsValue[key]) !== null && _ref !== void 0 ? _ref : startValue, startAt[key]);
          startUnit = startAt[key].unit;

          if (key === 'scale') {
            transform.scaleX = startValue;
            transform.scaleY = startValue;
          } else {
            transform[key] = startValue;
          }
        }

        if (startUnit !== endUnit) {
          startValue = startConvertToEndUnit({
            target: target,
            computedStyle: _this.computedStyle,
            style: cssName,
            value: startValue,
            startUnit: startUnit,
            endUnit: endUnit
          });

          if (key === 'scale') {
            transform.scaleX = startValue;
            transform.scaleY = startValue;
          } else {
            transform[key] = startValue;
          }
        }

        start[_this.transformName] = transform;
      } else if (cssName === 'filter') {
        var fKey = cssList.filterConvert[key] || key;
        filter = filter || (startData === varsValue ? _objectSpread({}, varsValue) : splitFilterToObject(styleValue) || {});
        filter[fKey] = filter[fKey] || initFilterValue[fKey];
        var _startValue = filter[fKey];

        if (startAt && key in startAt) {
          var _startAt$key$vars2;

          _startValue = _this.setStartAtValue((_startAt$key$vars2 = startAt[key].vars) !== null && _startAt$key$vars2 !== void 0 ? _startAt$key$vars2 : _startValue, startAt[key]);
          startUnit = startAt[key].unit;
          filter[fKey] = _startValue;
        }

        if (endUnit !== startUnit) {
          var _this$computedStyle;

          filter[fKey] = startConvertToEndUnit({
            target: target,
            computedStyle: _this.computedStyle,
            style: cssName,
            value: _startValue,
            startUnit: startUnit,
            endUnit: endUnit,
            fixed: ((_this$computedStyle = _this.computedStyle) === null || _this$computedStyle === void 0 ? void 0 : _this$computedStyle.position) === 'fixed'
          });
        }

        start[_this.filterName] = filter;
      } else {
        var _startAt$key2;

        startData = (_startAt$key2 = startAt[key]) !== null && _startAt$key2 !== void 0 ? _startAt$key2 : styleValue;

        if (!startData || startData === 'none' || startData === 'auto') {
          startData = '';
        } // 计算单位


        endUnit = propsData.unit[cssName];
        startUnit = _typeof(startData) === 'object' ? startData.unit : "".concat(startData).replace(/[^a-z|%]/g, '');
        startData = _this.setStartAtValue(styleValue, startAt[key]);

        if (endUnit !== startUnit) {
          var _this$computedStyle2;

          startData = startConvertToEndUnit({
            target: target,
            computedStyle: _this.computedStyle,
            style: cssName,
            value: parseFloat(startData),
            startUnit: startUnit,
            endUnit: endUnit,
            fixed: ((_this$computedStyle2 = _this.computedStyle) === null || _this$computedStyle2 === void 0 ? void 0 : _this$computedStyle2.position) === 'fixed'
          });
        }

        start[cssName] = parseFloat(startData) || getDefaultStart(cssName);
      }
    }

    return start;
  };

  this.render = function (ratio) {
    var propsData = _this.propsData,
        start = _this.start,
        t = _this.tweenVars;
    var tweenVars = t.style || {};

    if (start[_this.transformName] && !tweenVars[_this.transformName]) {
      tweenVars[_this.transformName] = _objectSpread({}, start[_this.transformName]);
    }

    if (start[_this.filterName] && !tweenVars[_this.filterName]) {
      tweenVars[_this.filterName] = _objectSpread({}, start[_this.filterName]);
    }

    var transform = tweenVars[_this.transformName];
    var filter = tweenVars[_this.filterName];
    var data = propsData.data,
        dataUnit = propsData.unit,
        dataCount = propsData.count,
        isTransform = propsData.isTransform;

    for (var key in data) {
      //Object.keys(data).forEach((key: string) => {
      var endValue = data[key];

      if (endValue.plugin) {
        tweenVars[key] = endValue.plugin.render(ratio);
        continue;
      }

      var isT = isTransform[key];
      var startValue = isT ? start[_this.transformName][key] : start[key];
      var unit = dataUnit[key];
      var count = dataCount[key];

      if (isT) {
        if (key === 'scale') {
          var xStart = start[_this.transformName].scaleX;
          var yStart = start[_this.transformName].scaleY;

          if (count.charAt(1) === '=') {
            transform.scaleX = xStart + endValue * ratio;
            transform.scaleY = yStart + endValue * ratio;
          } else {
            transform.scaleX = (endValue - xStart) * ratio + xStart;
            transform.scaleY = (endValue - yStart) * ratio + yStart;
          }
        } else {
          transform[key] = getValue(parseFloat(startValue), endValue, ratio, count, unit);
        }

        transform.text = getTransformValue(tweenVars[_this.transformName]);
      } else if (cssList.filter.indexOf(key) >= 0) {
        var fKey = cssList.filterConvert[key] || key;
        startValue = parseFloat(start[_this.filterName][fKey]) || 0;
        filter[fKey] = getValue(startValue, endValue, ratio, count, unit);
        filter.text = ''; //Object.keys(filter).forEach(filterKey => {

        for (var filterKey in filter) {
          if (filterKey === 'text') {
            continue;
          }

          filter.text = "".concat(filter.text, " ").concat(filterKey, "(").concat(filter[filterKey], ")").trim();
        } //});

      } else {
        var styleUnit = stylesToCss(key, 0);
        styleUnit = typeof styleUnit === 'number' ? 0 : styleUnit.replace(/[^a-z|%]/g, '');
        unit = unit || styleUnit;

        if (typeof endValue === 'string') {
          tweenVars[key] = endValue;
        } else {
          tweenVars[key] = getValue(startValue, endValue, ratio, count, unit);
        }
      }
    }

    return tweenVars;
  };

  this.props = _props;
  this.transformName = checkStyleName('transform');
  this.filterName = checkStyleName('filter') || 'filter';
  this.setDefaultData();
});

style.key = 'style';
style.className = 'style';
export default style;